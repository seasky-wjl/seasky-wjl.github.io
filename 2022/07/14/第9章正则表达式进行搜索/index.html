<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>第9章正则表达式进行搜索 | Mw&#39;s Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第9章：用正则表达式进行搜索9.1 正则表达式介绍&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;前两张中的过滤例子允许用匹配、比较和通配符操作符寻找数据。对基本的过滤（或者甚至是某些不那么基本的过滤），这样就足够了。但随着过滤条件的复杂性的增加，WHERE子句本身的复杂性也有必要增加。&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;这就是正则表达式变得有用的地方。正则表达式是用来匹配文本">
<meta property="og:type" content="article">
<meta property="og:title" content="第9章正则表达式进行搜索">
<meta property="og:url" content="http://example/2022/07/14/%E7%AC%AC9%E7%AB%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/index.html">
<meta property="og:site_name" content="Mw&#39;s Hexo">
<meta property="og:description" content="第9章：用正则表达式进行搜索9.1 正则表达式介绍&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;前两张中的过滤例子允许用匹配、比较和通配符操作符寻找数据。对基本的过滤（或者甚至是某些不那么基本的过滤），这样就足够了。但随着过滤条件的复杂性的增加，WHERE子句本身的复杂性也有必要增加。&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;这就是正则表达式变得有用的地方。正则表达式是用来匹配文本">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-14T12:25:29.000Z">
<meta property="article:modified_time" content="2022-09-12T00:27:43.884Z">
<meta property="article:author" content="mawan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mw's Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mw&#39;s Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-第9章正则表达式进行搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/14/%E7%AC%AC9%E7%AB%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2022-07-14T12:25:29.000Z" itemprop="datePublished">2022-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      第9章正则表达式进行搜索
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第9章：用正则表达式进行搜索"><a href="#第9章：用正则表达式进行搜索" class="headerlink" title="第9章：用正则表达式进行搜索"></a><center>第9章：用正则表达式进行搜索</center></h1><h2 id="9-1-正则表达式介绍"><a href="#9-1-正则表达式介绍" class="headerlink" title="9.1 正则表达式介绍"></a>9.1 正则表达式介绍</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;前两张中的过滤例子允许用匹配、比较和通配符操作符寻找数据。对基本的过滤（或者甚至是某些不那么基本的过滤），这样就足够了。但随着过滤条件的复杂性的增加，WHERE子句本身的复杂性也有必要增加。<br>&nbsp; &nbsp;&nbsp; &nbsp;这就是正则表达式变得有用的地方。正则表达式是用来匹配文本的特殊的串（字符集合）。如果你想从一个表达式中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，可以使用正则表达式。如果你想在一个文本块中找到所有重复的单词，可以使用一个正则表达式。如果你想替换一个页面中的所有URL为这些URL的实际HTML链接，也可以使用一个正则表达式（对于最后这个例子，或者是两个正则表达式）。<br>&nbsp; &nbsp;&nbsp; &nbsp;所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。<br>&nbsp; &nbsp;&nbsp; &nbsp;正则表达式用正则表达式语言来建立，正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言。与任意语言一样，正则表达式具有你必须学习的特殊的语法和指令。  </p>
<h2 id="9-2-使用MySQL正则表达式"><a href="#9-2-使用MySQL正则表达式" class="headerlink" title="9.2 使用MySQL正则表达式"></a>9.2 使用MySQL正则表达式</h2><p>&nbsp; &nbsp;&nbsp; &nbsp;正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式过滤SELECT检索出的数据。  </p>
<pre><code>    仅为正则表达式的一个子集：如果你熟悉正则表达式，需要注意：MySQL仅支持多数正则表达式实现的一个很小的子集。  </code></pre>
<h3 id="9-2-1-基本字符匹配"><a href="#9-2-1-基本字符匹配" class="headerlink" title="9.2.1 基本字符匹配"></a>9.2.1 基本字符匹配</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;下面语句检索列prod_name包含文本1000的所有行：  </p>
<blockquote>
<p>输入：SELECt prod_name FROM products WHERE prod_name REGEXP ‘1000’ ORDER BY prod_name;<br>分析：出关键字LIKE被REGEXP替代外，这条语句看上去非常像使用LIKE的语句。它告诉MySQL：REGEXP后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理。</p>
</blockquote>
<p>&nbsp; &nbsp;&nbsp; &nbsp;再来看下面的例子：  </p>
<blockquote>
<p>输入： SELECT prod_name FROM products WHERE prod_name REGEXP ‘.000’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出： </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JetPack 1000</td>
</tr>
<tr>
<td align="center">JetPack 2000</td>
</tr>
</tbody></table>
<blockquote>
<p>分析： 这里使用了正则表达式.000。其中.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，1000和2000都匹配且返回。  </p>
</blockquote>
<pre><code>    LIKE和REGEXP：在LIKE和REGEXP之间有一个重要的差别。请看一下两条语句：  

    SELECT prod_name
    FROM products
    WHERE prod_name LIKE &#39;1000&#39;
    ORDER BY prod_name;

    SELECt prod_name
    FROM products
    WHERE prod_name REGEXP &#39;1000&#39;
    ORDER BY prod_name;

    如果执行上述两条语，会发现第一条语句不返回数据，而第二条语句返回一行。为什么？  

    正如第8章所述，LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不会被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。那么，REGEXP能不能用来匹配整个列值（从而起与LIKE相同的作用）？答案是肯定的，用^和$定位符（anchor）即可。

    匹配不区分大小写 MySQL中的正则表达式匹配不区分大小写。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;。</code></pre>
<h3 id="9-2-2-进行OR匹配"><a href="#9-2-2-进行OR匹配" class="headerlink" title="9.2.2 进行OR匹配"></a>9.2.2 进行OR匹配</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;为搜索两个串之一（或者为这个串，或者为另一个串），使用|，如下所示：  </p>
<blockquote>
<p>输入：SELECT prod_name FROm products WHERE prod_Name REGEXP ‘1000|2000’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JetPack 1000</td>
</tr>
<tr>
<td align="center">JetPack 2000</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：语句中使用了正则表达式1000|2000。|为正则表达式的OR操作符。它表示匹配其中之一，因此1000和2000都匹配并返回。  </p>
</blockquote>
<p>&nbsp; &nbsp;&nbsp; &nbsp;使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。  </p>
<pre><code>    两个以上的OR条件：可以给出两个以上的OR条件。例如，&#39;1000 | 2000 | 3000&#39;将匹配1000或2000或3000。</code></pre>
<h3 id="9-2-3-匹配几个字符之一"><a href="#9-2-3-匹配几个字符之一" class="headerlink" title="9.2.3 匹配几个字符之一"></a>9.2.3 匹配几个字符之一</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;匹配任何单一字符。但是如果你只想匹配特定的字符，怎么办？可通过指定一组用[和]括起来的字符来完成，如下所示：</p>
<blockquote>
<p>输入：SELECT prod_name FROm products WHERE prod_name REGEXP ‘[123] Ton’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出：</p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 ton anvil</td>
</tr>
<tr>
<td align="center">2 ton anvil</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：这里，使用了正则表达式[123] Ton。[123]定义一组字符，它的意思式匹配1或2或3，因此，1 ton和2 ton都匹配且返回(没有3 ton)。  </p>
</blockquote>
<p>&nbsp; &nbsp;&nbsp; &nbsp;正如所见,[]是另一种形式的OR语句。事实上，正则表达式[123]Ton为[1|2|3]Ton的缩写，也可以使用后者。但是，需要用[]来定义OR语句查找什么。为更好地理解这一点，请看下面地的例子：  </p>
<blockquote>
<p>输入：SELECT prod_name FROM products WHERE prod_name REGEXP ‘1|2|3 Ton’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出： </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 ton anvil</td>
</tr>
<tr>
<td align="center">2 ton anvil</td>
</tr>
<tr>
<td align="center">JetPack 1000</td>
</tr>
<tr>
<td align="center">JetPack 2000</td>
</tr>
<tr>
<td align="center">TNT(1 stick)</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：这并不是期望的输出。两个要求的行被检索出来，但还检索出了另外3行。之所以这样是由于MySQL假定你的意思是’1’或’2’或’3 ton’。除非把字符|括在一个集合中，否则它将应用于整个串。<br>  字符串集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西。</p>
</blockquote>
<h3 id="9-2-4-匹配范围"><a href="#9-2-4-匹配范围" class="headerlink" title="9.2.4 匹配范围"></a>9.2.4 匹配范围</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹配数字0到9：[0123456789]<br>&nbsp; &nbsp;&nbsp; &nbsp;为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能上等同于上述数字列表：[0-9]<br>&nbsp; &nbsp;&nbsp; &nbsp;范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。例如：  </p>
<blockquote>
<p>输入：SELECT prod_name FROM products WHERE prod_name REGEXP ‘[1-5] Ton’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.5 ton anvil</td>
</tr>
<tr>
<td align="center">1 ton anvil</td>
</tr>
<tr>
<td align="center">2 ton anvil</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：这里使用正则表达式[1-5] Ton。[1-5]定义了一个范围，这个范围表达式意思是匹配1到5，因此返回3个匹配行。由于5 ton匹配，所以返回.5 ton。</p>
</blockquote>
<h3 id="9-2-5-匹配特殊字符"><a href="#9-2-5-匹配特殊字符" class="headerlink" title="9.2.5 匹配特殊字符"></a>9.2.5 匹配特殊字符</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;正则表达式语言具有特定含义的特殊字符构成。我们已经看到.、[]、|和-等，还有一些字符。请问，如果你需要匹配这些字符，应该怎么办呢？例如，如果要找出包含.字符的值，怎样搜索？请看下面的例子：  </p>
<blockquote>
<p>输入：SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘.’ ORDER BY vend_name;  </p>
</blockquote>
<p>输出:</p>
<table>
<thead>
<tr>
<th align="center">vend_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACME</td>
</tr>
<tr>
<td align="center">ANVIL R Us</td>
</tr>
<tr>
<td align="center">Furball Inc.</td>
</tr>
<tr>
<td align="center">Jet Set</td>
</tr>
<tr>
<td align="center">Jouets Et Ours</td>
</tr>
<tr>
<td align="center">LT Supplies</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：这并不是期望的输出，.匹配任意字符，因此每个行都被检索出来。  </p>
</blockquote>
<pre><code>    为了匹配特殊字符，必须用\\为前导。\\-表示查找-，用\\.表示查找.。</code></pre>
<blockquote>
<p>输入:SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\.’ ORDER BY vend_name;</p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">vend_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Furball Inc.</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：这才是期望的输出。\.匹配.,所以只检索出一行。这种处理就是所谓的转移（escaping），正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括.、|、[]以及迄今为止使用过的其他特殊字符。  </p>
</blockquote>
<pre><code>    \\也用来引用元字符（具有特殊含义的字符），如表所示。</code></pre>
<p>空白元字符：<br>| 元字符 | 说明 |<br>| :—-:| :—-:|<br>| \f   |  换页 |<br>| \n   |  换行 |<br>| \r   |  回车 |<br>| \t   |  制表 |<br>| \v   | 纵向制表 |</p>
<pre><code>    匹配\：为了匹配反斜杠（\）字符本身，需要使用\\\。
    \或\\?：多数正则表达式实现使用单个反斜杠转义特殊字符，一边能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解析一个，正则表达式库解释另外一个）。</code></pre>
<h3 id="9-2-6-匹配字符类"><a href="#9-2-6-匹配字符类" class="headerlink" title="9.2.6 匹配字符类"></a>9.2.6 匹配字符类</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。可以使用预定义的字符集，称为字符类（character class）。<br>|     类    |             说明           |<br>| :——-: |    :—-                |<br>| [:alnum:] |   任意字母和数字（同[a-zA-Z0-9]） |<br>| [:alpha:] |   任意字符（同[a-zA-Z]）          |<br>| [:blank:] |   空格和制表（同[\t]）           |<br>| [:cntrl:] |   ASCII控制字符（ASCII 0到31和127）|<br>| [:digit:] |   任意数字（同[0-9]）              |<br>| [:graph:] |   与[:print:]相同，但不包括空格     |<br>| [:lower:] |   任意小写字母（同[a-z]）           |<br>| [:print:] |   任意可打印字符                  |<br>| [:punct:] |   既不在[:alnum:]又不在[:cntrl:]中的任意字符   |<br>| [:space:] |   包括空格在内的任意空白字符（同[\f\n\r\t\v]） |<br>| [:upper:] |   任意大写字母（同[A-Z]）           |<br>| [:xdigit:] |   任意十六进制数字（同[a-fA-F0-9]）  |</p>
<h3 id="9-2-7-匹配多个实例"><a href="#9-2-7-匹配多个实例" class="headerlink" title="9.2.7 匹配多个实例"></a>9.2.7 匹配多个实例</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;目前为止使用的所有正则表达式都试图匹配单次出现。如果出现一个匹配，该行被检索出来，如果不存在，检索不出任何行。但有时需要对匹配的数目进行更强的控制。例如，你可能需要寻找所有的数，不管书中包含多少数字，或者你可能想寻找一个单词并且还能够适应一个尾随s（如果存在），等等。<br>&nbsp; &nbsp;&nbsp; &nbsp;者可以用正则表达式重复元字符来完成。<br>重复元字符：<br>| 元字符 | 说明          |<br>| :—-:| :————-|<br>|   *   |  0个或多个匹配 |<br>|   +   |  1个或多个匹配（等于{1,}） |<br>|   ?   |  0个或1个匹配（等于{0，1}） |<br>|  {n}  |  指定数目的匹配 |<br>| {n,}  | 不少于指定数目的匹配 |<br>| {n,m} | 匹配数目的范围（m不超过255） |</p>
<p>下面举几个例子。</p>
<blockquote>
<p>输入：SELECT prod_name FROM products WHERE prod-Name REGEXP ‘\([0-9] sticks?\)’;</p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TNT（1 stick）</td>
</tr>
<tr>
<td align="center">TNT（5 sticks）</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：正则表达式\([0-9] sticks\)需要解说一下。\(匹配(，[0-9]匹配任意数字（这个例子中为1和5），sticks？匹配stick和sticks（s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现），\)匹配)。没有？，匹配stick和sticks会非常困难。  </p>
</blockquote>
<p>以下例子匹配连在一起的4位数字：  </p>
<blockquote>
<p>输入：SELECT prod_name FROM products WHERE prod_name REGEXP ‘[[:digit:]]{4}’ ORDER BY prod_name;  </p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JetPack 1000</td>
</tr>
<tr>
<td align="center">JetPack 2000</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：如前所述，[:digit:]匹配任意数字，因为它为数字的一个集合。{4}确切地要求它前面地字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起地任意4位数字。  </p>
</blockquote>
<p>&nbsp; &nbsp;&nbsp; &nbsp;需要注意的是，在使用正则表达式时，编写某个特殊的表达式几乎总有不止一种方法。上面的例子也可以如下编写：  </p>
<blockquote>
<p>输入：SELECT prod_name FROM products WHERE prod_name REGEXP ‘[0-9][0-9][0-9][0-9]’ ORDER BY prod_name;  </p>
</blockquote>
<h3 id="9-2-8-定位符"><a href="#9-2-8-定位符" class="headerlink" title="9.2.8 定位符"></a>9.2.8 定位符</h3><p>&nbsp; &nbsp;&nbsp; &nbsp;目前为止的所有例子都是匹配一个传中任意的文本。为了匹配特定位置的文本，需要使用下表列出的定位符。<br>定位元字符<br>| 元字符   | 说明       |<br>| :—-:  | :——— |<br>|    ^    |  文本的开始 |<br>|    $    |  文本的末尾 |<br>| [[:&lt;:]] |    词的开始 |<br>| [[:&gt;:]] |    词的末尾 |</p>
<p>&nbsp; &nbsp;&nbsp; &nbsp;例如，如果你想找出以一个数（包括以小数点开始的数）开始的所有产品，怎么办？简单搜索[0-9\.]（或[[:digit:]\.]）不行，因为它将文本内任意位置查找匹配。解决办法是使用^定位符，如下所示：  </p>
<blockquote>
<p>输入： SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\.]’  ORDER BY prod_name;</p>
</blockquote>
<p>输出：  </p>
<table>
<thead>
<tr>
<th align="center">prod_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.5 ton anvil</td>
</tr>
<tr>
<td align="center">1 ton anvil</td>
</tr>
<tr>
<td align="center">2 ton anvil</td>
</tr>
</tbody></table>
<blockquote>
<p>分析：匹配串的开始。因此，^[0-9\.]只在.或任意数字为串中第一个字符时才匹配它们。没有^,则还要多检索4个别的行（那些中间有数字的行）。</p>
</blockquote>
<pre><code>    ^的双重用途：^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。  

    使REGEXP起类似LIKE的作用 本章前面说过，LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串，利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用的作用与LIKE一样。

    简单的正则表达式测试：
    可以在不使用数据库表的情况下用
    SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配）
    或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试
    验它们。相应的语法如下：

    SELECt &#39;hello&#39; REGEXP &#39;[0-9]&#39;;

    这个例子显然将返回0（因为文本hello中没有数字）。</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example/2022/07/14/%E7%AC%AC9%E7%AB%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/" data-id="cl7yu8i8h000k6s7e2l4xh59p" data-title="第9章正则表达式进行搜索" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/16/%E7%AC%AC10%E7%AB%A0%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          第10章创建计算字段
        
      </div>
    </a>
  
  
    <a href="/2022/07/14/%E7%AC%AC8%E7%AB%A0%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">第8章用通配符进行过滤</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" rel="tag">MySQL必知必会</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" style="font-size: 10px;">MySQL必知必会</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/11/morris%E9%81%8D%E5%8E%86/">morris遍历</a>
          </li>
        
          <li>
            <a href="/2022/07/18/%E7%AC%AC13%E7%AB%A0%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/">第13章分组数据</a>
          </li>
        
          <li>
            <a href="/2022/07/17/%E7%AC%AC12%E7%AB%A0%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/">第12章汇总数据</a>
          </li>
        
          <li>
            <a href="/2022/07/16/%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/">第11章使用数据处理函数</a>
          </li>
        
          <li>
            <a href="/2022/07/16/%E7%AC%AC10%E7%AB%A0%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/">第10章创建计算字段</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 mawan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>